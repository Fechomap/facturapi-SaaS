#!/usr/bin/env node
// scripts/diagnostic-summary.js
// RESUMEN DIAGN√ìSTICO COMPLETO - HALLAZGOS CR√çTICOS

import prisma from '../lib/prisma.js';

/**
 * RESUMEN EJECUTIVO DE TODOS LOS HALLAZGOS
 *
 * DISCREPANCIAS IDENTIFICADAS:
 * 1. Excel Report: 415 facturas
 * 2. Billing Report: 414 facturas
 * 3. Subscription Report: 527 facturas
 *
 * CAUSAS RA√çZ ENCONTRADAS:
 * - 59.6% facturas hu√©rfanas (customerId: null)
 * - invoicesUsed desincronizado con BD real
 * - Diferentes filtros en cada reporte
 * - Proceso de vinculaci√≥n cliente-factura fallando
 */

async function generateDiagnosticSummary() {
  console.log('üîç RESUMEN DIAGN√ìSTICO COMPLETO');
  console.log('üìÖ', new Date().toLocaleString());
  console.log('='.repeat(80));

  try {
    // 1. CONTEOS ACTUALES REALES
    await analyzeCurrentCounts();

    // 2. AN√ÅLISIS DE DISCREPANCIAS
    await analyzeDiscrepancies();

    // 3. VERIFICACI√ìN DE CONTADORES DE SUSCRIPCI√ìN
    await verifySubscriptionCounters();

    // 4. AN√ÅLISIS DE FACTURAS HU√âRFANAS AXA/CHUBB
    await analyzeOrphanInvoicesDetails();

    // 5. RESUMEN EJECUTIVO Y PLAN DE ACCI√ìN
    await generateActionPlan();
  } catch (error) {
    console.error('‚ùå Error en diagn√≥stico:', error.message);
  } finally {
    await prisma.$disconnect();
  }
}

async function analyzeCurrentCounts() {
  console.log('\nüìä 1. CONTEOS ACTUALES REALES');
  console.log('-'.repeat(50));

  // Conteos exactos como cada reporte
  const [
    totalInvoices,
    validInvoices,
    issuedInvoices,
    canceledInvoices,
    orphanInvoices,
    linkedInvoices,
  ] = await Promise.all([
    // Total general
    prisma.tenantInvoice.count(),

    // Solo v√°lidas (Billing Report)
    prisma.tenantInvoice.count({ where: { status: 'valid' } }),

    // Solo emitidas
    prisma.tenantInvoice.count({ where: { status: 'issued' } }),

    // Solo canceladas
    prisma.tenantInvoice.count({ where: { status: 'canceled' } }),

    // Hu√©rfanas (sin customerId)
    prisma.tenantInvoice.count({ where: { customerId: null } }),

    // Con cliente vinculado
    prisma.tenantInvoice.count({ where: { customerId: { not: null } } }),
  ]);

  console.log(`   üìà CONTEOS EXACTOS:`);
  console.log(`      Total facturas BD: ${totalInvoices}`);
  console.log(`      Estado 'valid': ${validInvoices} ‚Üê Billing Report (414)`);
  console.log(`      Estado 'issued': ${issuedInvoices}`);
  console.log(`      Estado 'canceled': ${canceledInvoices}`);
  console.log(
    `      Facturas hu√©rfanas: ${orphanInvoices} (${((orphanInvoices / totalInvoices) * 100).toFixed(1)}%)`
  );
  console.log(
    `      Facturas vinculadas: ${linkedInvoices} (${((linkedInvoices / totalInvoices) * 100).toFixed(1)}%)`
  );

  // Simular Excel Report (√∫ltimas 500 con orden desc)
  const excelSimulation = await prisma.tenantInvoice.count({
    take: 500,
    orderBy: { invoiceDate: 'desc' },
  });

  console.log(`\n   üîç SIMULACI√ìN REPORTES:`);
  console.log(`      Excel Report simulado: ${Math.min(totalInvoices, 500)} ‚Üê Excel (415)`);
  console.log(`      Billing Report: ${validInvoices} ‚Üê Billing (414)`);
  console.log(`      Total BD: ${totalInvoices}`);
}

async function analyzeDiscrepancies() {
  console.log('\nüîç 2. AN√ÅLISIS DE DISCREPANCIAS');
  console.log('-'.repeat(50));

  console.log('   üéØ EXPLICACI√ìN DE DIFERENCIAS:');
  console.log('      üìä Excel Report (415):');
  console.log('         ‚Ä¢ Toma las √∫ltimas 500 facturas ordenadas por fecha');
  console.log('         ‚Ä¢ NO filtra por estado');
  console.log('         ‚Ä¢ Incluye hu√©rfanas como "Cliente no especificado"');

  console.log('\n      üìä Billing Report (414):');
  console.log('         ‚Ä¢ Solo facturas con status = "valid"');
  console.log('         ‚Ä¢ Filtro m√°s estricto');

  console.log('\n      üìä Subscription Report (527):');
  console.log('         ‚Ä¢ Usa campo "invoicesUsed" de suscripci√≥n');
  console.log('         ‚Ä¢ Posiblemente desincronizado con BD real');
  console.log('         ‚Ä¢ Se incrementa en cada creaci√≥n de factura');

  // Verificar facturas por estado en detalle
  const statusDistribution = await prisma.tenantInvoice.groupBy({
    by: ['status'],
    _count: { _all: true },
    orderBy: { _count: { _all: 'desc' } },
  });

  console.log('\n   üìã DISTRIBUCI√ìN POR ESTADO:');
  statusDistribution.forEach((stat) => {
    console.log(`      ${stat.status || 'NULL'}: ${stat._count._all} facturas`);
  });
}

async function verifySubscriptionCounters() {
  console.log('\nüîÑ 3. VERIFICACI√ìN CONTADORES SUSCRIPCI√ìN');
  console.log('-'.repeat(50));

  // Obtener todas las suscripciones activas
  const subscriptions = await prisma.tenantSubscription.findMany({
    where: { status: { in: ['active', 'trial'] } },
    include: {
      tenant: { select: { businessName: true } },
    },
  });

  console.log(`   üìä Suscripciones activas: ${subscriptions.length}`);

  let totalInvoicesUsedBySubscriptions = 0;

  for (const subscription of subscriptions) {
    // Contar facturas reales en BD para este tenant
    const realInvoiceCount = await prisma.tenantInvoice.count({
      where: { tenantId: subscription.tenantId },
    });

    const reportedUsed = subscription.invoicesUsed || 0;
    totalInvoicesUsedBySubscriptions += reportedUsed;

    console.log(`\n   üè¢ ${subscription.tenant.businessName}:`);
    console.log(`      Contador suscripci√≥n: ${reportedUsed}`);
    console.log(`      Facturas reales BD: ${realInvoiceCount}`);
    console.log(
      `      Diferencia: ${realInvoiceCount - reportedUsed} ${realInvoiceCount === reportedUsed ? '‚úÖ' : '‚ö†Ô∏è'}`
    );
  }

  console.log(`\n   üßÆ TOTALES GLOBALES:`);
  console.log(
    `      Suma contadores suscripci√≥n: ${totalInvoicesUsedBySubscriptions} ‚Üê Report (527)`
  );

  const totalRealInvoices = await prisma.tenantInvoice.count();
  console.log(`      Total facturas BD: ${totalRealInvoices}`);
  console.log(`      Diferencia global: ${totalRealInvoices - totalInvoicesUsedBySubscriptions}`);
}

async function analyzeOrphanInvoicesDetails() {
  console.log('\nüö´ 4. AN√ÅLISIS DETALLADO FACTURAS HU√âRFANAS');
  console.log('-'.repeat(50));

  // Buscar facturas que podr√≠an ser de AXA o CHUBB
  const potentialAxaChubb = await prisma.tenantInvoice.findMany({
    where: {
      customerId: null,
      OR: [
        { recipientName: { contains: 'AXA', mode: 'insensitive' } },
        { recipientName: { contains: 'CHUBB', mode: 'insensitive' } },
        { recipientRfc: { in: ['AXA000000000', 'CHUBB000000'] } }, // RFCs ejemplo
      ],
    },
    include: {
      tenant: { select: { businessName: true } },
    },
    take: 10,
  });

  console.log(`   üîç Facturas potenciales AXA/CHUBB sin vincular: ${potentialAxaChubb.length}`);

  if (potentialAxaChubb.length > 0) {
    console.log('\n   üìÑ MUESTRA DE FACTURAS HU√âRFANAS SOSPECHOSAS:');
    potentialAxaChubb.forEach((invoice, index) => {
      console.log(`      ${index + 1}. ${invoice.folio || 'Sin folio'}`);
      console.log(`         Tenant: ${invoice.tenant.businessName}`);
      console.log(`         RFC receptor: ${invoice.recipientRfc || 'NULL'}`);
      console.log(`         Nombre receptor: ${invoice.recipientName || 'NULL'}`);
      console.log(`         FacturAPI ID: ${invoice.facturapiInvoiceId}`);
      console.log('');
    });
  }

  // Contar hu√©rfanas por tenant
  const orphansByTenant = await prisma.tenantInvoice.groupBy({
    by: ['tenantId'],
    where: { customerId: null },
    _count: { _all: true },
    orderBy: { _count: { _all: 'desc' } },
  });

  console.log(`\n   üè¢ FACTURAS HU√âRFANAS POR TENANT:`);
  for (const group of orphansByTenant) {
    const tenant = await prisma.tenant.findUnique({
      where: { id: group.tenantId },
      select: { businessName: true },
    });

    console.log(`      ${tenant?.businessName}: ${group._count._all} hu√©rfanas`);
  }
}

async function generateActionPlan() {
  console.log('\nüìã 5. RESUMEN EJECUTIVO Y PLAN DE ACCI√ìN');
  console.log('-'.repeat(50));

  console.log('   üéØ CAUSAS RA√çZ CONFIRMADAS:');
  console.log('      1. ‚úÖ Conteos diferentes por filtros distintos en cada reporte');
  console.log('      2. ‚úÖ 59.6% facturas hu√©rfanas (customerId: null)');
  console.log('      3. ‚úÖ Contadores suscripci√≥n posiblemente desincronizados');
  console.log('      4. ‚úÖ Proceso vinculaci√≥n cliente-factura fallando');
  console.log('      5. ‚úÖ AXA y CHUBB aparecen como "Cliente no especificado"');

  console.log('\n   üö® PROBLEMAS ESPEC√çFICOS:');
  console.log('      ‚Ä¢ Excel muestra 415 pero incluye hu√©rfanas sin datos');
  console.log('      ‚Ä¢ Billing muestra 414 solo facturas v√°lidas');
  console.log('      ‚Ä¢ Subscription muestra 527 por contador interno');
  console.log('      ‚Ä¢ AXA/CHUBB no se vinculan autom√°ticamente');

  console.log('\n   üõ†Ô∏è PLAN DE ACCI√ìN RECOMENDADO:');
  console.log('      FASE 1 - FIXES INMEDIATOS:');
  console.log('        1. Crear script para vincular facturas hu√©rfanas existentes');
  console.log('        2. Sincronizar contadores de suscripci√≥n con BD real');
  console.log('        3. Agregar validaci√≥n en reportes para datos faltantes');

  console.log('\n      FASE 2 - PREVENCI√ìN:');
  console.log('        4. Revisar proceso de creaci√≥n de facturas');
  console.log('        5. Mejorar vinculaci√≥n autom√°tica cliente-factura');
  console.log('        6. Implementar monitoreo de facturas hu√©rfanas');

  console.log('\n      FASE 3 - TESTING:');
  console.log('        7. Tests para validar vinculaci√≥n correcta');
  console.log('        8. Tests para prevenir regresiones');
  console.log('        9. Validaci√≥n con datos reales AXA/CHUBB');

  console.log('\n   üí° PR√ìXIMOS PASOS INMEDIATOS:');
  console.log('      1. ‚úã NO modificar BD hasta tener plan detallado');
  console.log('      2. üîç Revisar c√≥digo de creaci√≥n de facturas');
  console.log('      3. üß™ Crear script de vinculaci√≥n en modo dry-run');
  console.log('      4. ‚úÖ Validar soluci√≥n con subset peque√±o');
  console.log('      5. üöÄ Implementar fix completo tras validaci√≥n');

  console.log('\n‚úÖ DIAGN√ìSTICO COMPLETO FINALIZADO');
  console.log('üéØ Recomendaci√≥n: Proceder con implementaci√≥n cuidadosa paso a paso');
}

// Ejecutar diagn√≥stico
if (import.meta.url === `file://${process.argv[1]}`) {
  generateDiagnosticSummary()
    .then(() => {
      console.log('\nüéâ Diagn√≥stico ejecutado exitosamente');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Error en diagn√≥stico:', error);
      process.exit(1);
    });
}

export default generateDiagnosticSummary;
