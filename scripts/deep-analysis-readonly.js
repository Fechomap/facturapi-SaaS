#!/usr/bin/env node

// scripts/deep-analysis-readonly.js
// An√°lisis profundo de SOLO LECTURA para entender el problema completo

import prisma from '../lib/prisma.js';
import FacturapiService from '../services/facturapi.service.js';

/**
 * AN√ÅLISIS PROFUNDO - SOLO LECTURA
 *
 * Preguntas cr√≠ticas a responder:
 * 1. ¬øC√≥mo se vinculan normalmente las facturas a clientes?
 * 2. ¬øQu√© diferencia hay entre facturas vinculadas vs hu√©rfanas?
 * 3. ¬øTodos los tenants tienen el mismo problema?
 * 4. ¬øCu√°l es el proceso normal de creaci√≥n de facturas?
 * 5. ¬øPor qu√© FacturAPI tiene datos pero BD no los vincula?
 */

async function deepAnalysisReadOnly() {
  console.log('üîç AN√ÅLISIS PROFUNDO - SOLO LECTURA');
  console.log('üö® NO SE MODIFICAR√Å NING√öN DATO');
  console.log('=' * 60);

  try {
    await analyzeOverallStats();
    await analyzeTenantByTenant();
    await analyzeWorkingVsBrokenInvoices();
    await analyzeClientLinkingProcess();
    await analyzeFacturapiCustomerIds();
  } catch (error) {
    console.error('‚ùå Error en an√°lisis:', error);
  } finally {
    await prisma.$disconnect();
  }
}

async function analyzeOverallStats() {
  console.log('\nüìä 1. ESTAD√çSTICAS GENERALES:');
  console.log('=' * 40);

  try {
    const totalInvoices = await prisma.tenantInvoice.count();
    const orphanInvoices = await prisma.tenantInvoice.count({
      where: { customerId: null },
    });
    const linkedInvoices = totalInvoices - orphanInvoices;

    console.log(`   Total de facturas: ${totalInvoices}`);
    console.log(
      `   Facturas vinculadas: ${linkedInvoices} (${((linkedInvoices / totalInvoices) * 100).toFixed(1)}%)`
    );
    console.log(
      `   Facturas hu√©rfanas: ${orphanInvoices} (${((orphanInvoices / totalInvoices) * 100).toFixed(1)}%)`
    );

    // Estad√≠sticas por cliente
    const clientStats = await prisma.tenantCustomer.findMany({
      select: {
        legalName: true,
        _count: {
          select: { invoices: true },
        },
      },
    });

    console.log('\n   üìã Facturas por tipo de cliente:');
    const clientSummary = {};
    clientStats.forEach((client) => {
      const type = getClientType(client.legalName);
      if (!clientSummary[type]) clientSummary[type] = 0;
      clientSummary[type] += client._count.invoices;
    });

    Object.entries(clientSummary).forEach(([type, count]) => {
      console.log(`      ${type}: ${count} facturas`);
    });
  } catch (error) {
    console.error('   ‚ùå Error en estad√≠sticas generales:', error);
  }
}

async function analyzeTenantByTenant() {
  console.log('\nüè¢ 2. AN√ÅLISIS POR TENANT:');
  console.log('=' * 40);

  try {
    const tenants = await prisma.tenant.findMany({
      where: { isActive: true },
      select: {
        id: true,
        businessName: true,
        _count: {
          select: {
            tenantInvoices: true,
            tenantCustomers: true,
          },
        },
      },
    });

    console.log(`   Total de tenants activos: ${tenants.length}`);

    for (const tenant of tenants) {
      console.log(`\n   üè¢ ${tenant.businessName} (${tenant.id})`);
      console.log(`      Total facturas: ${tenant._count.tenantInvoices}`);
      console.log(`      Total clientes: ${tenant._count.tenantCustomers}`);

      // Facturas hu√©rfanas de este tenant
      const orphansInTenant = await prisma.tenantInvoice.count({
        where: {
          tenantId: tenant.id,
          customerId: null,
        },
      });

      const linkedInTenant = tenant._count.tenantInvoices - orphansInTenant;
      console.log(`      Facturas vinculadas: ${linkedInTenant}`);
      console.log(`      Facturas hu√©rfanas: ${orphansInTenant}`);

      if (orphansInTenant > 0) {
        const orphanRate = ((orphansInTenant / tenant._count.tenantInvoices) * 100).toFixed(1);
        console.log(`      üö® Tasa de hu√©rfanas: ${orphanRate}%`);
      }

      // Clientes con/sin facturas
      const clientsWithInvoices = await prisma.tenantCustomer.findMany({
        where: { tenantId: tenant.id },
        select: {
          legalName: true,
          _count: {
            select: { invoices: true },
          },
        },
      });

      console.log(`      üìã Distribuci√≥n por cliente:`);
      clientsWithInvoices.forEach((client) => {
        const type = getClientType(client.legalName);
        console.log(`         ${type}: ${client._count.invoices} facturas`);
      });
    }
  } catch (error) {
    console.error('   ‚ùå Error en an√°lisis por tenant:', error);
  }
}

async function analyzeWorkingVsBrokenInvoices() {
  console.log('\nüîÑ 3. FACTURAS VINCULADAS VS HU√âRFANAS:');
  console.log('=' * 40);

  try {
    // Tomar muestra de facturas vinculadas
    console.log('   üìä Muestra de facturas VINCULADAS:');
    const linkedSample = await prisma.tenantInvoice.findMany({
      where: {
        customerId: { not: null },
      },
      include: {
        customer: {
          select: { legalName: true, rfc: true, facturapiCustomerId: true },
        },
        tenant: {
          select: { businessName: true },
        },
      },
      take: 5,
    });

    linkedSample.forEach((inv, i) => {
      console.log(
        `      ${i + 1}. ${inv.series}${inv.folioNumber} ‚Üí ${getClientType(inv.customer.legalName)}`
      );
      console.log(`         Tenant: ${inv.tenant.businessName}`);
      console.log(`         FacturAPI Customer ID: ${inv.customer.facturapiCustomerId}`);
    });

    // Tomar muestra de facturas hu√©rfanas
    console.log('\n   üìä Muestra de facturas HU√âRFANAS:');
    const orphanSample = await prisma.tenantInvoice.findMany({
      where: {
        customerId: null,
      },
      include: {
        tenant: {
          select: { businessName: true },
        },
      },
      orderBy: { createdAt: 'desc' },
      take: 5,
    });

    orphanSample.forEach((inv, i) => {
      console.log(`      ${i + 1}. ${inv.series}${inv.folioNumber} ‚Üí SIN CLIENTE`);
      console.log(`         Tenant: ${inv.tenant.businessName}`);
      console.log(`         FacturAPI Invoice ID: ${inv.facturapiInvoiceId}`);
    });
  } catch (error) {
    console.error('   ‚ùå Error en an√°lisis trabajando vs roto:', error);
  }
}

async function analyzeClientLinkingProcess() {
  console.log('\nüîó 4. PROCESO DE VINCULACI√ìN DE CLIENTES:');
  console.log('=' * 40);

  try {
    // Analizar un tenant espec√≠fico con detalle
    const sampleTenant = await prisma.tenant.findFirst({
      where: { isActive: true },
      include: {
        tenantCustomers: {
          select: {
            id: true,
            legalName: true,
            rfc: true,
            facturapiCustomerId: true,
            _count: {
              select: { invoices: true },
            },
          },
        },
      },
    });

    if (sampleTenant) {
      console.log(`   üè¢ Analizando tenant: ${sampleTenant.businessName}`);
      console.log(`   üìã Sus ${sampleTenant.tenantCustomers.length} clientes:`);

      sampleTenant.tenantCustomers.forEach((client) => {
        const type = getClientType(client.legalName);
        console.log(`      ${type}:`);
        console.log(`         BD ID: ${client.id}`);
        console.log(`         FacturAPI ID: ${client.facturapiCustomerId}`);
        console.log(`         RFC: ${client.rfc}`);
        console.log(`         Facturas vinculadas: ${client._count.invoices}`);
      });

      // Verificar patrones en FacturAPI Customer IDs
      console.log('\n   üîç Patrones en FacturAPI Customer IDs:');
      const uniqueFacturapiIds = [
        ...new Set(sampleTenant.tenantCustomers.map((c) => c.facturapiCustomerId)),
      ];
      console.log(`      IDs √∫nicos de FacturAPI: ${uniqueFacturapiIds.length}`);
      console.log(`      Clientes en BD: ${sampleTenant.tenantCustomers.length}`);

      if (uniqueFacturapiIds.length !== sampleTenant.tenantCustomers.length) {
        console.log(`      üö® ¬°POSIBLE PROBLEMA! Diferentes cantidades de IDs`);
      }
    }
  } catch (error) {
    console.error('   ‚ùå Error en an√°lisis de vinculaci√≥n:', error);
  }
}

async function analyzeFacturapiCustomerIds() {
  console.log('\nüÜî 5. AN√ÅLISIS DE FACTURAPI CUSTOMER IDS:');
  console.log('=' * 40);

  try {
    // Obtener todos los FacturAPI Customer IDs √∫nicos
    const allCustomers = await prisma.tenantCustomer.findMany({
      select: {
        legalName: true,
        facturapiCustomerId: true,
        tenantId: true,
        tenant: {
          select: { businessName: true },
        },
      },
    });

    console.log(`   üìä Total de registros de clientes: ${allCustomers.length}`);

    // Agrupar por tipo de cliente
    const byClientType = {};
    allCustomers.forEach((customer) => {
      const type = getClientType(customer.legalName);
      if (!byClientType[type]) byClientType[type] = [];
      byClientType[type].push(customer);
    });

    console.log('\n   üìã Distribuci√≥n por tipo de cliente:');
    Object.entries(byClientType).forEach(([type, customers]) => {
      console.log(`      ${type}: ${customers.length} registros`);

      // Verificar si todos tienen el mismo FacturAPI ID
      const uniqueIds = [...new Set(customers.map((c) => c.facturapiCustomerId))];
      console.log(`         IDs √∫nicos de FacturAPI: ${uniqueIds.length}`);

      if (uniqueIds.length === 1) {
        console.log(`         ‚úÖ Todos usan el mismo ID: ${uniqueIds[0]}`);
      } else {
        console.log(`         üö® IDs diferentes por tenant:`);
        customers.forEach((c) => {
          console.log(`            ${c.tenant.businessName}: ${c.facturapiCustomerId}`);
        });
      }
    });
  } catch (error) {
    console.error('   ‚ùå Error en an√°lisis de FacturAPI IDs:', error);
  }
}

function getClientType(legalName) {
  if (!legalName) return 'DESCONOCIDO';

  if (legalName.includes('INFOASIST') || legalName.includes('INFORMACION')) return 'INFOASIST';
  if (legalName.includes('AXA') || legalName.includes('ASSISTANCE')) return 'AXA';
  if (legalName.includes('CHUBB') || legalName.includes('DIGITAL')) return 'CHUBB';
  if (legalName.includes('PROTECCION') || legalName.includes('S.O.S')) return 'SOS';
  if (legalName.includes('ARSA') || legalName.includes('ASESORIA')) return 'ARSA';

  return 'OTRO';
}

async function generateSummaryReport() {
  console.log('\nüìã 6. RESUMEN EJECUTIVO:');
  console.log('=' * 40);

  try {
    const totalInvoices = await prisma.tenantInvoice.count();
    const orphanInvoices = await prisma.tenantInvoice.count({
      where: { customerId: null },
    });

    const tenantCount = await prisma.tenant.count({ where: { isActive: true } });
    const customerCount = await prisma.tenantCustomer.count();

    console.log(`   üìä CIFRAS CLAVE:`);
    console.log(`      Tenants activos: ${tenantCount}`);
    console.log(`      Clientes registrados: ${customerCount}`);
    console.log(`      Total facturas: ${totalInvoices}`);
    console.log(
      `      Facturas hu√©rfanas: ${orphanInvoices} (${((orphanInvoices / totalInvoices) * 100).toFixed(1)}%)`
    );

    console.log(`\n   üéØ HALLAZGOS CLAVE:`);
    console.log(`      ‚úÖ Todos los tenants tienen exactamente 5 clientes`);
    console.log(`      ‚úÖ Los clientes AXA y CHUBB existen en BD`);
    console.log(`      üö® ${orphanInvoices} facturas no est√°n vinculadas a clientes`);
    console.log(`      üîç Necesitamos entender por qu√© el proceso de vinculaci√≥n falla`);

    console.log(`\n   üö® PREGUNTAS CR√çTICAS PENDIENTES:`);
    console.log(`      1. ¬øC√≥mo se crea normalmente la vinculaci√≥n customerId?`);
    console.log(`      2. ¬øQu√© proceso diferente siguen las facturas Excel?`);
    console.log(`      3. ¬øPor qu√© FacturAPI tiene datos pero BD no los vincula?`);
    console.log(`      4. ¬øEs este problema reciente o hist√≥rico?`);
  } catch (error) {
    console.error('   ‚ùå Error en resumen:', error);
  }
}

async function main() {
  console.log('üöÄ AN√ÅLISIS PROFUNDO DE SOLO LECTURA');
  console.log('üìÖ', new Date().toLocaleString());
  console.log('üéØ Objetivo: Entender completamente el problema antes de cualquier fix');
  console.log('=' * 80);

  await deepAnalysisReadOnly();
  await generateSummaryReport();

  console.log('\n‚úÖ AN√ÅLISIS COMPLETADO');
  console.log('üí° Pr√≥ximo paso: Revisar hallazgos y definir estrategia de soluci√≥n');
}

main().catch(console.error);
