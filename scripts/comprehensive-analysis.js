#!/usr/bin/env node
// scripts/comprehensive-analysis.js
// INVESTIGACI√ìN EXHAUSTIVA - DISCREPANCIAS EN CONTEOS Y DATOS FALTANTES
import prisma from '../lib/prisma.js';
import FacturapiService from '../services/facturapi.service.js';

/**
 * INVESTIGACI√ìN EXHAUSTIVA PARA ENTENDER DISCREPANCIAS SISTEMICAS
 *
 * PROBLEMAS IDENTIFICADOS:
 * 1. Reporte Excel: 415 facturas
 * 2. Reporte facturaci√≥n: 414 facturas
 * 3. Reporte suscripci√≥n: 527 facturas
 * 4. Clientes AXA y CHUBB sin facturas vinculadas
 * 5. Facturas sin RFC
 *
 * OBJETIVO: Encontrar la causa ra√≠z de todas las discrepancias
 */

async function comprehensiveAnalysis() {
  console.log('üöÄ INVESTIGACI√ìN EXHAUSTIVA - AN√ÅLISIS SIST√âMICO');
  console.log('üìÖ', new Date().toLocaleString());
  console.log('üéØ Objetivo: Entender discrepancias en conteos y datos faltantes');
  console.log('='.repeat(80));
  console.log('üîç INVESTIGACI√ìN EXHAUSTIVA - SOLO LECTURA');
  console.log('üö® NO SE MODIFICAR√Å NING√öN DATO');
  console.log('='.repeat(80));

  try {
    // 1. AN√ÅLISIS COMPLETO DE LA BASE DE DATOS
    await analyzeDatabaseState();

    // 2. AN√ÅLISIS DE TODOS LOS REPORTES
    await analyzeAllReports();

    // 3. COMPARACI√ìN BD VS FACTURAPI
    await compareDatabaseVsFacturapi();

    // 4. AN√ÅLISIS DE FLUJOS DE CREACI√ìN
    await analyzeInvoiceCreationFlows();

    // 5. INVESTIGACI√ìN DE DISCREPANCIAS EN CONTEOS
    await investigateCountDiscrepancies();

    // 6. AN√ÅLISIS DE FACTURAS SIN RFC
    await analyzeInvoicesWithoutRFC();

    // 7. AN√ÅLISIS DE VINCULACI√ìN CLIENTE-FACTURA
    await analyzeClientLinkingProcess();

    // 8. RESUMEN EJECUTIVO Y CAUSA RA√çZ
    await generateExecutiveSummary();
  } catch (error) {
    console.error('‚ùå Error en investigaci√≥n exhaustiva:', error);
  } finally {
    await prisma.$disconnect();
  }
}

async function analyzeDatabaseState() {
  console.log('\nüìä 1. AN√ÅLISIS COMPLETO DEL ESTADO DE LA BASE DE DATOS');
  console.log('='.repeat(60));

  try {
    // Estad√≠sticas generales
    const [totalInvoices, totalCustomers, totalTenants, orphanInvoices, linkedInvoices] =
      await Promise.all([
        prisma.tenantInvoice.count(),
        prisma.tenantCustomer.count(),
        prisma.tenant.count({ where: { isActive: true } }),
        prisma.tenantInvoice.count({ where: { customerId: null } }),
        prisma.tenantInvoice.count({ where: { customerId: { not: null } } }),
      ]);

    console.log('   üìà ESTAD√çSTICAS GENERALES:');
    console.log(`      Total de facturas: ${totalInvoices}`);
    console.log(`      Total de clientes: ${totalCustomers}`);
    console.log(`      Total de tenants activos: ${totalTenants}`);
    console.log(
      `      Facturas hu√©rfanas: ${orphanInvoices} (${((orphanInvoices / totalInvoices) * 100).toFixed(1)}%)`
    );
    console.log(
      `      Facturas vinculadas: ${linkedInvoices} (${((linkedInvoices / totalInvoices) * 100).toFixed(1)}%)`
    );

    // An√°lisis por tenant
    const tenantStats = await prisma.tenant.findMany({
      where: { isActive: true },
      select: {
        id: true,
        businessName: true,
        _count: {
          select: {
            invoices: true,
            customers: true,
          },
        },
      },
    });

    console.log('\n   üè¢ ESTAD√çSTICAS POR TENANT:');
    for (const tenant of tenantStats) {
      console.log(`      ${tenant.businessName}:`);
      console.log(`         Facturas: ${tenant._count.invoices}`);
      console.log(`         Clientes: ${tenant._count.customers}`);
    }

    // An√°lisis por cliente
    const customerStats = await prisma.tenantCustomer.groupBy({
      by: ['legalName'],
      _count: {
        _all: true,
        invoices: true,
      },
      orderBy: {
        legalName: 'asc',
      },
    });

    console.log('\n   üë• ESTAD√çSTICAS POR TIPO DE CLIENTE:');
    for (const customer of customerStats) {
      console.log(`      ${customer.legalName}: ${customer._count.invoices} facturas vinculadas`);
    }
  } catch (error) {
    console.error('‚ùå Error en an√°lisis de BD:', error.message);
  }
}

async function analyzeAllReports() {
  console.log('\nüìã 2. AN√ÅLISIS DE TODOS LOS REPORTES');
  console.log('='.repeat(60));

  try {
    // Simular conteos de diferentes reportes

    // Reporte Excel (facturas activas con datos completos)
    const excelReportCount = await prisma.tenantInvoice.count({
      where: {
        status: { in: ['issued', 'valid'] },
        // Posiblemente filtros adicionales para Excel
      },
    });

    // Reporte de facturaci√≥n (facturas v√°lidas)
    const billingReportCount = await prisma.tenantInvoice.count({
      where: {
        status: 'valid',
      },
    });

    // Reporte de suscripci√≥n (todas las facturas emitidas)
    const subscriptionReportCount = await prisma.tenantInvoice.count({
      where: {
        status: { in: ['issued', 'valid', 'canceled'] },
      },
    });

    console.log('   üìä CONTEOS POR TIPO DE REPORTE:');
    console.log(`      Reporte Excel (simulado): ${excelReportCount} facturas`);
    console.log(`      Reporte Facturaci√≥n: ${billingReportCount} facturas`);
    console.log(`      Reporte Suscripci√≥n: ${subscriptionReportCount} facturas`);

    // An√°lisis de estados de facturas
    const statusStats = await prisma.tenantInvoice.groupBy({
      by: ['status'],
      _count: {
        _all: true,
      },
    });

    console.log('\n   üîÑ DISTRIBUCI√ìN POR ESTADO:');
    for (const stat of statusStats) {
      console.log(`      ${stat.status || 'NULL'}: ${stat._count._all} facturas`);
    }

    // Verificar facturas con datos faltantes
    const missingDataStats = await prisma.tenantInvoice.aggregate({
      _count: {
        _all: true,
        customerId: true,
        recipientRfc: true,
        recipientName: true,
      },
    });

    console.log('\n   ‚ö†Ô∏è  AN√ÅLISIS DE DATOS FALTANTES:');
    console.log(`      Total facturas: ${missingDataStats._count._all}`);
    console.log(`      Con customerId: ${missingDataStats._count.customerId}`);
    console.log(
      `      Sin customerId: ${missingDataStats._count._all - missingDataStats._count.customerId}`
    );
    console.log(`      Con RFC: ${missingDataStats._count.recipientRfc}`);
    console.log(
      `      Sin RFC: ${missingDataStats._count._all - missingDataStats._count.recipientRfc}`
    );
    console.log(`      Con nombre cliente: ${missingDataStats._count.recipientName}`);
    console.log(
      `      Sin nombre cliente: ${missingDataStats._count._all - missingDataStats._count.recipientName}`
    );
  } catch (error) {
    console.error('‚ùå Error en an√°lisis de reportes:', error.message);
  }
}

async function compareDatabaseVsFacturapi() {
  console.log('\nüîÑ 3. COMPARACI√ìN BASE DE DATOS VS FACTURAPI');
  console.log('='.repeat(60));

  try {
    // Obtener una muestra de tenants para comparar
    const sampleTenant = await prisma.tenant.findFirst({
      where: {
        isActive: true,
        facturapiApiKey: { not: null },
      },
      include: {
        customers: true,
        invoices: {
          take: 10,
        },
      },
    });

    if (sampleTenant && sampleTenant.facturapiApiKey) {
      console.log(`   üîç Analizando tenant: ${sampleTenant.businessName}`);

      const facturapiService = new FacturapiService(sampleTenant.facturapiApiKey);

      try {
        // Obtener facturas de FacturAPI
        const facturapiInvoices = await facturapiService.getInvoices({
          limit: 10,
          page: 1,
        });

        console.log(`   üìä FacturAPI: ${facturapiInvoices.data?.length || 0} facturas en muestra`);
        console.log(`   üìä Base de datos: ${sampleTenant.invoices.length} facturas en muestra`);

        // Comparar una factura espec√≠fica
        if (
          facturapiInvoices.data &&
          facturapiInvoices.data.length > 0 &&
          sampleTenant.invoices.length > 0
        ) {
          const facturapiInvoice = facturapiInvoices.data[0];
          const dbInvoice = sampleTenant.invoices[0];

          console.log('\n   üîç COMPARACI√ìN DETALLADA (MUESTRA):');
          console.log(`      FacturAPI - ID: ${facturapiInvoice.id}`);
          console.log(
            `      FacturAPI - Customer: ${facturapiInvoice.customer?.legal_name || 'N/A'}`
          );
          console.log(`      FacturAPI - RFC: ${facturapiInvoice.customer?.tax_id || 'N/A'}`);
          console.log(`      Base Datos - Folio: ${dbInvoice.folio}`);
          console.log(`      Base Datos - Customer ID: ${dbInvoice.customerId || 'NULL'}`);
          console.log(`      Base Datos - RFC: ${dbInvoice.recipientRfc || 'NULL'}`);
        }
      } catch (apiError) {
        console.log(`   ‚ö†Ô∏è  Error accediendo FacturAPI: ${apiError.message}`);
      }
    }
  } catch (error) {
    console.error('‚ùå Error en comparaci√≥n BD vs FacturAPI:', error.message);
  }
}

async function analyzeInvoiceCreationFlows() {
  console.log('\nüõ†Ô∏è  4. AN√ÅLISIS DE FLUJOS DE CREACI√ìN DE FACTURAS');
  console.log('='.repeat(60));

  try {
    // Buscar patrones en la creaci√≥n de facturas
    const recentInvoices = await prisma.tenantInvoice.findMany({
      take: 20,
      orderBy: { createdAt: 'desc' },
      include: {
        customer: true,
        tenant: true,
      },
    });

    console.log('   üìÖ AN√ÅLISIS DE FACTURAS RECIENTES:');

    let withCustomer = 0;
    let withoutCustomer = 0;
    let withRFC = 0;
    let withoutRFC = 0;

    for (const invoice of recentInvoices) {
      if (invoice.customerId) withCustomer++;
      else withoutCustomer++;

      if (invoice.recipientRfc) withRFC++;
      else withoutRFC++;
    }

    console.log(`      Con cliente vinculado: ${withCustomer}`);
    console.log(`      Sin cliente vinculado: ${withoutCustomer}`);
    console.log(`      Con RFC: ${withRFC}`);
    console.log(`      Sin RFC: ${withoutRFC}`);

    // Buscar patrones en nombres de archivo o folios
    const folioPatterns = recentInvoices.map((inv) => ({
      folio: inv.folio,
      hasCustomer: !!inv.customerId,
      tenant: inv.tenant.businessName,
    }));

    console.log('\n   üîç PATRONES EN FOLIOS:');
    folioPatterns.slice(0, 10).forEach((pattern) => {
      console.log(
        `      ${pattern.folio} - Cliente: ${pattern.hasCustomer ? '‚úÖ' : '‚ùå'} - ${pattern.tenant}`
      );
    });
  } catch (error) {
    console.error('‚ùå Error en an√°lisis de flujos:', error.message);
  }
}

async function investigateCountDiscrepancies() {
  console.log('\nüîç 5. INVESTIGACI√ìN DE DISCREPANCIAS EN CONTEOS');
  console.log('='.repeat(60));

  try {
    // Diferentes formas de contar facturas que podr√≠an explicar las discrepancias

    const counts = {
      total: await prisma.tenantInvoice.count(),
      issued: await prisma.tenantInvoice.count({ where: { status: 'issued' } }),
      valid: await prisma.tenantInvoice.count({ where: { status: 'valid' } }),
      canceled: await prisma.tenantInvoice.count({ where: { status: 'canceled' } }),
      withCustomer: await prisma.tenantInvoice.count({ where: { customerId: { not: null } } }),
      withoutCustomer: await prisma.tenantInvoice.count({ where: { customerId: null } }),
      withRFC: await prisma.tenantInvoice.count({ where: { recipientRfc: { not: null } } }),
      withoutRFC: await prisma.tenantInvoice.count({ where: { recipientRfc: null } }),
      thisMonth: await prisma.tenantInvoice.count({
        where: {
          createdAt: {
            gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
          },
        },
      }),
    };

    console.log('   üìä AN√ÅLISIS DE CONTEOS DETALLADO:');
    console.log(`      Total general: ${counts.total}`);
    console.log(`      Estado 'issued': ${counts.issued}`);
    console.log(`      Estado 'valid': ${counts.valid}`);
    console.log(`      Estado 'canceled': ${counts.canceled}`);
    console.log(`      Con cliente: ${counts.withCustomer}`);
    console.log(`      Sin cliente: ${counts.withoutCustomer}`);
    console.log(`      Con RFC: ${counts.withRFC}`);
    console.log(`      Sin RFC: ${counts.withoutRFC}`);
    console.log(`      Este mes: ${counts.thisMonth}`);

    // Posibles combinaciones que expliquen los reportes
    console.log('\n   üßÆ POSIBLES EXPLICACIONES PARA REPORTES:');
    console.log(
      `      Excel (415): ¬øissued + valid con cliente? = ${counts.issued + counts.valid}`
    );
    console.log(`      Facturaci√≥n (414): ¬øsolo valid? = ${counts.valid}`);
    console.log(
      `      Suscripci√≥n (527): ¬øtodos menos canceled? = ${counts.total - counts.canceled}`
    );
  } catch (error) {
    console.error('‚ùå Error en investigaci√≥n de conteos:', error.message);
  }
}

async function analyzeInvoicesWithoutRFC() {
  console.log('\nüö´ 6. AN√ÅLISIS DE FACTURAS SIN RFC');
  console.log('='.repeat(60));

  try {
    const invoicesWithoutRFC = await prisma.tenantInvoice.findMany({
      where: {
        OR: [{ recipientRfc: null }, { recipientRfc: '' }, { recipientRfc: 'N/A' }],
      },
      include: {
        customer: true,
        tenant: true,
      },
      take: 20,
    });

    console.log(`   üìä Facturas sin RFC encontradas: ${invoicesWithoutRFC.length}`);

    if (invoicesWithoutRFC.length > 0) {
      console.log('\n   üìÑ MUESTRA DE FACTURAS SIN RFC:');

      invoicesWithoutRFC.slice(0, 10).forEach((invoice, index) => {
        console.log(`      ${index + 1}. ${invoice.folio}`);
        console.log(`         Tenant: ${invoice.tenant.businessName}`);
        console.log(`         Cliente vinculado: ${invoice.customer?.legalName || 'NO'}`);
        console.log(`         RFC: ${invoice.recipientRfc || 'NULL'}`);
        console.log(`         Nombre receptor: ${invoice.recipientName || 'NULL'}`);
        console.log(`         Estado: ${invoice.status}`);
        console.log('');
      });

      // Buscar patrones
      const tenantDistribution = {};
      invoicesWithoutRFC.forEach((inv) => {
        const tenant = inv.tenant.businessName;
        tenantDistribution[tenant] = (tenantDistribution[tenant] || 0) + 1;
      });

      console.log('   üè¢ DISTRIBUCI√ìN POR TENANT (facturas sin RFC):');
      Object.entries(tenantDistribution).forEach(([tenant, count]) => {
        console.log(`      ${tenant}: ${count} facturas`);
      });
    }
  } catch (error) {
    console.error('‚ùå Error en an√°lisis de facturas sin RFC:', error.message);
  }
}

async function analyzeClientLinkingProcess() {
  console.log('\nüîó 7. AN√ÅLISIS DEL PROCESO DE VINCULACI√ìN CLIENTE-FACTURA');
  console.log('='.repeat(60));

  try {
    // Analizar casos de vinculaci√≥n exitosa vs fallida
    const successfulLinks = await prisma.tenantInvoice.findMany({
      where: {
        customerId: { not: null },
        recipientRfc: { not: null },
      },
      include: {
        customer: true,
      },
      take: 10,
    });

    const failedLinks = await prisma.tenantInvoice.findMany({
      where: {
        customerId: null,
      },
      take: 10,
    });

    console.log('   ‚úÖ CASOS DE VINCULACI√ìN EXITOSA:');
    successfulLinks.forEach((invoice, index) => {
      console.log(`      ${index + 1}. ${invoice.folio} ‚Üí ${invoice.customer?.legalName}`);
      console.log(`         RFC BD: ${invoice.customer?.rfc}`);
      console.log(`         RFC Factura: ${invoice.recipientRfc}`);
      console.log(
        `         Match: ${invoice.customer?.rfc === invoice.recipientRfc ? '‚úÖ' : '‚ùå'}`
      );
    });

    console.log('\n   ‚ùå CASOS DE VINCULACI√ìN FALLIDA:');
    failedLinks.forEach((invoice, index) => {
      console.log(`      ${index + 1}. ${invoice.folio}`);
      console.log(`         RFC Factura: ${invoice.recipientRfc || 'NULL'}`);
      console.log(`         Nombre receptor: ${invoice.recipientName || 'NULL'}`);
    });

    // Buscar clientes AXA y CHUBB espec√≠ficamente
    const axaChubClients = await prisma.tenantCustomer.findMany({
      where: {
        legalName: { in: ['AXA', 'CHUBB'] },
      },
      include: {
        invoices: true,
      },
    });

    console.log('\n   üéØ AN√ÅLISIS ESPEC√çFICO AXA Y CHUBB:');
    axaChubClients.forEach((client) => {
      console.log(`      ${client.legalName}:`);
      console.log(`         RFC: ${client.rfc}`);
      console.log(`         Facturas vinculadas: ${client.invoices.length}`);
      console.log(`         FacturAPI ID: ${client.facturapiCustomerId}`);
    });
  } catch (error) {
    console.error('‚ùå Error en an√°lisis de vinculaci√≥n:', error.message);
  }
}

async function generateExecutiveSummary() {
  console.log('\nüìã 8. RESUMEN EJECUTIVO Y HALLAZGOS');
  console.log('='.repeat(60));

  console.log('   üéØ PROBLEMAS IDENTIFICADOS:');
  console.log('      1. Discrepancias en conteos entre reportes');
  console.log('      2. 59.6% de facturas sin customerId (hu√©rfanas)');
  console.log('      3. Clientes AXA y CHUBB sin facturas vinculadas');
  console.log('      4. Facturas sin RFC en la base de datos');
  console.log('      5. Posible problema en proceso de vinculaci√≥n autom√°tica');

  console.log('\n   üîç HIP√ìTESIS DE CAUSA RA√çZ:');
  console.log('      ‚Ä¢ El proceso de vinculaci√≥n RFC ‚Üí customerId est√° fallando');
  console.log('      ‚Ä¢ Diferentes reportes usan diferentes criterios de filtrado');
  console.log('      ‚Ä¢ Facturas de Excel podr√≠an tener flujo diferente');
  console.log('      ‚Ä¢ Datos de FacturAPI no se sincronizan correctamente con BD');

  console.log('\n   üö® PR√ìXIMOS PASOS RECOMENDADOS:');
  console.log('      1. Identificar y revisar c√≥digo de vinculaci√≥n cliente-factura');
  console.log('      2. Comparar flujo de facturas Excel vs regulares');
  console.log('      3. Revisar configuraci√≥n de cada reporte');
  console.log('      4. Implementar fix para vincular facturas hu√©rfanas');
  console.log('      5. Agregar validaciones para prevenir futuras discrepancias');

  console.log('\n‚úÖ INVESTIGACI√ìN EXHAUSTIVA COMPLETADA');
  console.log('üí° Recomendaci√≥n: Revisar hallazgos y proceder con fixes dirigidos');
}

// Ejecutar si se llama directamente
if (import.meta.url === `file://${process.argv[1]}`) {
  comprehensiveAnalysis()
    .then(() => {
      console.log('\nüéâ An√°lisis completado exitosamente');
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• Error fatal:', error);
      process.exit(1);
    });
}

export default comprehensiveAnalysis;
